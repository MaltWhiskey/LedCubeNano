#ifndef DISPLAY_H
#define DISPLAY_H
#include "Color.h"
/* Pin configuration of the TLC5940, 28-Pin PDIP top view

          ----O----
    OUT1 |1      28| OUT0
    OUT2 |2      27| VPRG  -> GND
    OUT3 |3      26| SIN   <-
    OUT4 |4   T  25| SCLK  <-
      .  |5   L  24| XLAT  <-
      .  |6   C  23| BLANK -> 10K Resistor  -> VCC
      .  |7   5  22| GND
      .  |8   9  21| VCC   -> 104 Capacitor -> GND
      .  |9   4  20| IREF  ->  2K Resistor  -> GND
      .  |10  0  19| DCPRG -> VCC
      .  |11     18| GSCLK <-
      .  |12     17| SOUT  -> SIN next TLC
      .  |13     16| XERR
    OUT14|14     15| OUT15
          ---------

    OUT15 MSB  ....  OUT0 LSB */

// Definition of the hardware for using 2xTLC5940
#define CHANNELS    16 * 2
#define CHNBITS     CHANNELS * 12
#define CHNBYTES    CHNBITS / 8
#define SPISPEED    5000000

/* These are the output pins inputing to the TLC5940. The GSCLK is generated by hardware 
 * Timer2 (OC2B PWM). The BLANK (OC1B PWM) and XLAT (OC1A PWM) outputs are controlled by
 * software, but hardware Timer1 is used to generate the interrupt.
 * SPI is used to send data to the TLC5940. SCK is on pin 13 and MOSI on pin 11 */ 
#define XLAT    9
#define BLANK   10
#define GSCLK   3
#define SIN     11
#define SCLK    13

// Definition of the hardware layers
#define X_LAYERS	3
#define Y_LAYERS	6
#define Z_LAYERS	3

class Display {
public:
  // Definition of the hardware layers
  static const uint8_t width  = X_LAYERS;
  static const uint8_t height = Y_LAYERS;
  static const uint8_t depth  = Z_LAYERS;
  // Global brightness settings buffered input
  uint8_t globalBrightness = 0xff;
private:
  // Global brightness setting displayed
  uint8_t displayedBrightness = 0xff;
  /* The memory of the entire cube, double buffered */
  Color m_rgbCube[2][width][height][depth];
  /* One buffer is currently being used for display and the other buffer is the canvas
   * for rendering. These buffers will swap places after a call to update, this is when
   * a new frame is ready to be displayed and right before the bottom layer is about to
   * be turned on (top to bottom vertical blank). While the top layer is turned on the
   * data for the bottom layer (y=0) is being send in. */
  volatile uint8_t m_displayedCube = 0;
  volatile uint8_t m_renderingCube = 1;
  /* When the animation routines have a frame ready update is called and a buffer switch
   * will be done right before the bottom layer data is being send in */
  volatile bool m_nextFrameReady = false;
  /* Hardware LED address mapping for getting the right LED offset see PCB schematic.
   * The table has the following layout: LED0R, LED0G, LED0B, LED1R, ..., LED09G, LED09B
   * There are some holes in this table, some are spare led addresses, others are unused.
   * Every led has a common anode and 3 cathodes and every cathode has a separate address
   * There are [3] rows of LEDs with [3] LEDs in each row and every led has [3] colors.*/
  uint8_t m_ledChannel[depth][width][3] = {
  {{  9,  10,  11}, {  6,   7,   8}, {  3,   4,   5}},
  {{ 25,  26,  27}, { 22,  23,  24}, {  1,   2,   0}},
  {{ 28,  29,  30}, { 19,  20,  21}, { 17,  18,  16}}
  };
  /* This is the pin mapping for multiplexing the layers of the led cube, starting with
   * the bottom layer. All layers are switched with a mosfet LOW=ON, HIGH=OFF, they are
   * connected with a 1K pull up resistor as to not switch them on at boot up time. */
  uint8_t m_layerPin[6] = {1<<0,1<<1,1<<2,1<<3,1<<4,1<<5};
  /* Number of bytes that are needed to send all bits to the TLC's. (12 bits/channel) */
  uint8_t m_channelBuffer[CHNBYTES];
  /* There should be only one displayed layer that is set to LOW, all other layers should
   * be set to HIGH. The displaying of the layers will start at the bottom (y=0). Every
   * cycle turns off the current layer first and than turns on the next one. */
  uint8_t m_LayerOffset = 0;
  /* Holding the pin for the current and the next layer has a performance advantage
   * resulting in less switching time between the layers. This minimizes the time that
   * all layers are off */
  uint8_t m_currentLayerPin = m_layerPin[0];
  uint8_t m_nextLayerPin    = m_layerPin[1];
public:
  // Gets a display reference to enable calling public methods
  static Display &instance() {
    // Create exactly one Display object with the private contructor
    static Display display;
    // Return the one and only display object
    return display;
  };
  // Start timers and interrupts. Method instead of class contructor for compatibility
  // Arduino tends to mess with interrupts after initialization of global objects. 
  void begin();
  // Updates the display en clears the rendering buffer, called by animations
  void update();
  // Unfortunately i have to expose this to the world because it needs to be called
  // from the static interrupt service routines at set times to switch layers.
  void multiplex();
  // Get a reference to a color, this can than be copied or manipulated otherwise.
  Color& color(const uint8_t x, const uint8_t y, const uint8_t z);
  Color& colored(const uint8_t x, const uint8_t y, const uint8_t z);
private:
  // Not allowed to make an object of the class, implemented singleton pattern
  Display(){};
  // Copy constructor is also disabled
  Display(Display const&);
  // Assigment operator is also disabled 
  void operator=(Display const&);
private:
  // Internal methods to send data to the led drivers
  void setChannel(const uint16_t channel, const uint8_t data);
  void setChannelBuffer(const uint8_t layer);
  void sendChannelBuffer();
};
inline Color& Display::color(const uint8_t x, const uint8_t y, const uint8_t z) {
  return m_rgbCube[m_renderingCube][x][y][z];
}
inline Color& Display::colored(const uint8_t x, const uint8_t y, const uint8_t z) {
  return m_rgbCube[m_displayedCube][x][y][z];
}
#endif